#	OS Lab7 Report
岳士超  
2012011295

--------


## 练习1

1. **理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题, 在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。**
> 与semaphore相关联的函数有:
> 
> 1. ``void up(semaphore_t *sem)``
> > 关中断  
> > 如果等待队列为空，则让sem->value++  
> > 如果等待队列非空，则唤醒等待队列中第一个进程  
> > 开中断  
> 
> 2. ``void down(semaphore_t *sem)``
> > 关中断  
> > 如果sem->value>0, 让其减一，关中断返回  
> > 反之，让当前进程进入等待队列并挂起，开中断进入schedule  
> > 醒来后关中断，将自己从等待队列中删除，开中断返回  
> 

2. **在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同**
> 在内核中创建一个sem_pool, 每次用户申请semaphore的时候调用系统调用，返回一个sem的指针。up和down均通过系统调用来实现, 比如sys_up, sys_down. 唯一区别是这里涉及进程权限的改变，所有对于信号量的操作都需要在内核态中完成

## 练习2
1. **完成内核级条件变量和基于内核级条件变量的哲学家就餐问题在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程**
> 一个condvar对应一个monitor  
> 假设有两个人，A等待B发信号  
> monitor的mutex保证了只有一个人在管程中  
> monitor的next是用来B等待A退出管程时用的  
> A退出管程后需要解锁next或mutex  
> 其实我觉得mutex和next可以合二为一

3. **在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同**
> 在内核中创建一个condvar_pool, 每次用户申请condvar的时候调用系统调用，返回一个condvar的指针。wait和signal均通过系统调用来实现, 比如sys_waitcond, sys_signalcond. 这里其实不需要权限的转变